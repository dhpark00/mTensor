(* ::Package:: *)

(* :Title: mPerm.m *)
(* :Summary: Manipulating signed permutations *)
(* :Context: mTensor`mPerm` *)
(* :Package Version: 2024.03 *)
(* :Mathematica Version: 9.0 *)

BeginPackage["mTensor`mPerm`"]

(******* Usage messages for the exported symbols and functions ******)

(***** MODE 0 *****)
PermMax::usage = ""
ToImag::usage  = ""
ToCycl::usage  = ""

(* Heads *)
Imag::usage   = ""
GenSet::usage = ""

(***** MODE 1 *****)
InversePerm::usage   = ""  (* postTensorTranspose *)
MakePermGroup::usage = ""  (* TindexSort, VD, SetComponents *)
Orbits::usage        = ""  (* checkSymAndKind *)
PermMemberQ::usage   = ""  (* vanishingObjectQ *)
PermuteList::usage   = ""  (* VD *)

(********************************************************************)
Begin["`Private`"]

(* due to PermutationList *)
If [System`$VersionNumber < 9.0, Throw @ Message[General::err, "Version >= 9 is required!"]]

(********************************************************************)
(****************************** MODE 0 ******************************)
(********************************************************************)
(*
    CyclesPhased: {Cycles[{...}], s}, where Abs[s] == 1
*)

(* remove empty perms from GenSet *)
GenSet[pre___, {Cycles[{}], 1}, post___] := GenSet[pre, post]

(* the largest point moved by the perm *)
PermMax[{cycl_Cycles, _}]  := PermutationMax[cycl]
PermMax[s_. * Imag[ns___]] := Length[{ns}]  (* not checked the validity of Imag[ns] *)
PermMax[GenSet[ps___]]     := Max[0, PermMax /@ {ps}]

(* Imag -> CyclesPhased, e.g., -Imag[2,1] => {Cycles[{{1,2}}], -1} *)
ToCycl[s_. * Imag[ns___]] := {PermutationCycles[{ns}], s} /; Abs[s] == 1

(* List -> CyclesPhased *)
ToCycl[imagL_List] := {PermutationCycles[imagL], 1}

(* CyclesPhased -> Imag *)
ToImag[{cycl_Cycles, s_}]              := ToImag[{cycl, s}, PermutationMax[cycl]]
ToImag[{cycl_Cycles, s_}, len_Integer] := s * Imag @@ PermutationList[cycl, len]

(* List -> Imag *)
ToImag[cyclL_List, len_Integer] := Imag @@ PermutationList[Cycles @ cyclL, len]
ToImag[0,         _]            := 0  (* for CanonicalPerm *)

(* is a CyclesPhased *)
permCyclesQ[{cycl_Cycles, s_}] := PermutationCyclesQ[cycl] /; Abs[s] == 1
permCyclesQ[___]               := False

(* is a set of CyclesPhased, with the head GenSet *)
gensetQ[GenSet[___?permCyclesQ]] := True
gensetQ[___]                     := False

(********************************************************************)
(****************************** MODE 1 ******************************)
(********************************************************************)
(*
    CyclesSigned: {Cycles[{...}], +1|-1}
*)

(* inverse permutation of CyclesPhased *)
InversePerm[x_?NumericQ * perm_] := 1/x InversePerm[perm]
InversePerm[{cycl_Cycles, s_}]   := {InversePermutation[cycl], 1/s}
InversePerm[Imag[ns___]]         := Imag @@ Ordering[{ns}]

(* returns the group generated by gs of CyclesSigned *)
(*Options[MakePermGroup] = {MMALink -> False}*)
MakePermGroup[GenSet[],  ___]                      := {}
MakePermGroup[gs_GenSet,              opts___Rule] := MakePermGroup[gs, PermMax @ gs, opts]
MakePermGroup[gs_GenSet, len_Integer, opts___Rule] :=
    (*If [MMALink /. {opts} /. Options[MakePermGroup],  (* True for MMALink mode, False for Math mode *)
        linkMakePermGroup[gs, len],
    (* else *)*)
        toCyclesSigned[#, len]& /@ GroupElements[gensetToPermGroup[gs, len]]
    (*]*)

(* returns the sorted orbits of the points under the action of the group generated by gs of CyclesSigned *)
Orbits[pts_List, gs_GenSet, len_Integer] := GroupOrbits[gensetToPermGroup[gs, len], pts]

PermMemberQ::invalid = "`1` is not a valid `2`."
PermMemberQ[perm_:{_Cycles, _Integer}, len_Integer, gs_GenSet] :=
    If [len < Max[PermMax @ perm, PermMax @ gs],
        Message[PermMemberQ::invalid, len, "length"]; False,
    (* else *)
        GroupElementQ[gensetToPermGroup[gs, len], toCyclesProper[perm, len]]
    ]
PermMemberQ[s_. * imag_Imag, len_Integer, gs_GenSet] := PermMemberQ[ToCycl[s * imag], len, gs]

(* permutes the points of a list according to the perm *)
PermuteList[argL_List, {cycl_Cycles, _}] := Permute[argL, cycl]
PermuteList[argL_List, s_. * imag_Imag]  := PermuteList[argL, List @@ imag]
PermuteList[argL_List, imagL_List]       := argL[[ Ordering[imagL] ]]

(* GenSet of CyclesSigned -> PermutationGroup *)
gensetToPermGroup[GenSet[scycl___], len_Integer] := PermutationGroup[ toCyclesProper[#, len]& /@ {scycl} ]

(* CyclesSigned -> Cycles *) (* Note: NOT CyclesPhased -> Cycles *)
toCyclesProper[{Cycles[cycl_],  1}, len_Integer] := Cycles[cycl]
toCyclesProper[{Cycles[cycl_], -1}, len_Integer] := Cycles @ Append[cycl, len + {1,2}]

(* Cycles -> CyclesSigned *)
toCyclesSigned[Cycles[cycl_], len_Integer] :=
    {Cycles @ DeleteCases[cycl, {___, len + 1, ___}], If [PermutationReplace[len + 1, Cycles[cycl]] === len + 1, 1, -1]}

(********************************************************************)
End[ ] (* end the private context *)

EndPackage[ ]  (* end the package context *)
